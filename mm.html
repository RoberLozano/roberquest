<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Map</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        #map-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: #333;
        }

        .controls {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 20px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
        }

        #fileInput {
            display: none;
        }

        .map-button {
            background: #333;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }

        .map-button:hover {
            background: #444;
        }

        #searchBox {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 5px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
        }

        #svg-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        #layersPanel {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 5px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        #layersHeader {
            padding: 5px;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            background: #2a2a2a;
            z-index: 2;
        }

        #layerSearch {
            width: calc(100% - 16px);
            padding: 5px 8px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 3px;
            font-size: 14px;
            background: #333;
            color: #fff;
        }

        #layersList {
            max-height: 40vh;
            overflow-y: auto;
            padding: 10px;
        }

        .layer-item.hidden {
            display: none;
        }

        .layer-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .layer-item input {
            margin-right: 8px;
        }

        .layer-item label {
            cursor: pointer;
            user-select: none;
            color: #fff;
        }

        /* Estilos para el panel lateral */
        #sidePanel {
            position: fixed;
            top: 0;
            right: -320px;
            /* Cambiar left por right */
            width: 300px;
            height: 100%;
            background: #1a1a1a;
            color: #fff;
            transition: right 0.3s ease;
            /* Cambiar left por right en transition */
            z-index: 1000;
            padding: 10px;
            box-sizing: border-box;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            /* Invertir sombra */
        }

        #sidePanel.open {
            right: 0;
            /* Cambiar left por right */
        }

        #togglePanel {
            position: fixed;
            top: 10px;
            right: 10px;
            /* Cambiar left por right */
            z-index: 1001;
            background: rgba(26, 26, 26, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
        }

        /* Añadir estilos para el botón de wifi */
        .wifi-button {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .wifi-button svg {
            width: 24px;
            height: 24px;
            fill: #666;
        }

        .wifi-button.online svg {
            fill: #4CAF50;
        }

        .wifi-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }

        #characterContextMenu {
            position: absolute;
            display: none;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            min-width: 150px;
        }

        #characterContextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        #characterContextMenu li {
            padding: 8px 12px;
            color: #fff;
            cursor: pointer;
            border-bottom: 1px solid #444;
        }

        #characterContextMenu li:last-child {
            border-bottom: none;
        }

        #characterContextMenu li:hover {
            background: #444;
        }

        #characterContextMenu .menu-delete {
            color: #ff4444;
        }

        #characterContextMenu .placeholder {
            color: #666;
            font-style: italic;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/4.7.0/firebase.js"></script>
    <script src='js/coor.js'></script>
    <script src='js/utils.js'></script>
    <script src='js/D.js'></script>
    <script src='js/habilidades.js'></script>
    <script src='js/inventario.js'></script>
    <script src='js/localizaciones.js'></script>
    <script src='js/armaduras.js'></script>
    <script src='js/rol.js'></script>
    <script src="https://cdn.jsdelivr.net/npm/@luncheon/simplify-svg-path@0.2.0"></script>
</head>

<body>
    <div id="map-container">
        <div id="svg-container"></div>
    </div>

    <button id="togglePanel">☰</button>

    <div id="sidePanel">
        <div class="controls">
            <label for="fileInput" class="map-button">
                Load Map
            </label>
            <input type="file" id="fileInput" accept="image/svg+xml">
            <label for="characterInput" class="map-button">
                Add Character
            </label>
            <input type="file" id="characterInput" accept="image/*" style="display: none;">
            <button class="map-button" id="zoomIn">+</button>
            <button class="map-button" id="zoomOut">-</button>
            <button class="map-button" id="resetView">Reset</button>
            v 0.007
        </div>
        <div id="searchBox">
            <input type="text" id="searchInput" placeholder="Enter name to zoom">
            <button class="map-button" id="searchButton">Zoom</button>
        </div>
        <div id="layersPanel">
            <div id="layersHeader">
                <input type="text" id="layerSearch" placeholder="Buscar capas...">
            </div>
            <div id="layersList"></div>
        </div>
    </div>

    <!-- Añadir botón de sincronización después del sidePanel -->
    <button class="wifi-button" id="syncButton" title="Modo offline">
        <svg viewBox="0 0 24 24">
            <path
                d="M12,21L15.6,16.2C14.6,15.45 13.35,15 12,15C10.65,15 9.4,15.45 8.4,16.2L12,21M12,3C7.95,3 4.21,4.34 1.2,6.6L3,9C5.5,7.12 8.62,6 12,6C15.38,6 18.5,7.12 21,9L22.8,6.6C19.79,4.34 16.05,3 12,3M12,9C9.3,9 6.81,9.89 4.8,11.4L6.6,13.8C8.1,12.67 9.97,12 12,12C14.03,12 15.9,12.67 17.4,13.8L19.2,11.4C17.19,9.89 14.7,9 12,9Z" />
        </svg>
    </button>

    <div id="characterContextMenu">
        <ul>
            <li id="togglePath">Mostrar camino</li>
            <li id="deleteRoute" class="menu-delete">Eliminar ruta</li>
            <li id="deleteCharacter" class="menu-delete">Eliminar personaje</li>
            <li id="rotate"> Rotar <input type="range" min="-180" max="180" value="0" class="slider" id="myAngle"
                    onchange="rotate(activeCharacter,this.value)"> </li>
            <li class="placeholder">Mostrar stats</li>
            <li class="placeholder">Editar personaje</li>
            <li class="placeholder">Cambiar imagen</li>
        </ul>
    </div>

    <script>
        let scale = 1;
        let panning = false;
        let pointX = 0;
        let pointY = 0;
        let start = { x: 0, y: 0 };
        let svgElement = null;
        let draggedCharacter = null;
        activeCharacter = null;
        let characters = new Map(); // Para mantener registro de personajes
        let personajes = new Map(); // Para mantener el objeto personaje si existe en firebase


        const mapContainer = document.getElementById("map-container");
        const svgContainer = document.getElementById("svg-container");

        const iconSize = 50;

        // Agregar variable global para almacenar las rutas de personajes
        const characterRoutes = new Map();
        // Si se emuestra el rastro al mover
        let rastro = true;

        // Definir tooltip para mostrar distancia mientras se mueve un personaje
        const tooltip = document.createElement('div');
        tooltip.style.cssText = "position: fixed; display: none; background: rgba(0,0,0,0.8); color: white; padding: 5px; border-radius: 3px; z-index: 1100; font-size: 12px;";
        document.body.appendChild(tooltip);

        // Nueva función helper para generar ruta suave con curvas Bezier (Catmull-Rom a Bezier)
        function generateSmoothPath(points) {
            //hacerlo con simplify-svg-path para reducir el número de puntos   
            return simplifySvgPath(points);
            // if (points.length < 2) return "";
            // let d = `M ${points[0].x} ${points[0].y} `;
            // if (points.length === 2) {
            //     d += `L ${points[1].x} ${points[1].y}`;
            //     return d;
            // }
            // for (let i = 0; i < points.length - 1; i++) {
            //     const p0 = i === 0 ? points[i] : points[i - 1];
            //     const p1 = points[i];
            //     const p2 = points[i + 1];
            //     const p3 = (i + 2 < points.length) ? points[i + 2] : p2;
            //     const cp1x = p1.x + (p2.x - p0.x) / 6;
            //     const cp1y = p1.y + (p2.y - p0.y) / 6;
            //     const cp2x = p2.x - (p3.x - p1.x) / 6;
            //     const cp2y = p2.y - (p3.y - p1.y) / 6;
            //     d += `C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y} `;
            // }
            // return d;
        }

        // Modificar updateCharacterRoute para dibujar menos muestras y suavizar el camino con curvas Bezier.
        // Además, se posiciona el tooltip relativo al personaje para que al mover el mapa su posición se mantenga.
        function updateCharacterRoute(charElement, newX, newY) {
            let route = characterRoutes.get(charElement) || [];
            const threshold = 0.3; // Añadir muestra solo si la distancia es mayor a 5 unidades
            if (route.length === 0) {
                route.push({ x: newX, y: newY });
            } else {
                const lastPoint = route[route.length - 1];
                const dx = newX - lastPoint.x, dy = newY - lastPoint.y;
                if (Math.sqrt(dx * dx + dy * dy) >= threshold) {
                    // if (true) {
                    route.push({ x: newX, y: newY });
                }
            }
            characterRoutes.set(charElement, route);

            // Calcular distancia total recorrida
            let totalDistance = 0;
            for (let i = 1; i < route.length; i++) {
                const dx = route[i].x - route[i - 1].x;
                const dy = route[i].y - route[i - 1].y;
                totalDistance += Math.sqrt(dx * dx + dy * dy);
            }

            const bbox = charElement.getBoundingClientRect();
            tooltip.style.display = 'block';
            tooltip.style.left = `${bbox.right + 10}px`;
            tooltip.style.top = `${bbox.top + 10}px`;
            tooltip.innerText = `Dist: ${totalDistance.toFixed(2)}`;
            clearTimeout(tooltip.hideTimeout);
            tooltip.hideTimeout = setTimeout(() => {
                tooltip.style.display = 'none';
            }, 2000);
        }

        // File input handler
        document.getElementById('fileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file && file.type === "image/svg+xml") {
                const reader = new FileReader();
                reader.onload = function (event) {
                    svgContainer.innerHTML = event.target.result;
                    svgElement = svgContainer.querySelector('svg');
                    adjustContainerToSVG();
                }
                reader.readAsText(file);
            } else {
                alert("Please upload a valid SVG file.");
            }
        });

        // Character input handler
        document.getElementById('characterInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    addCharacterToMap(event.target.result, e.target.files[0].name);
                }
                reader.readAsDataURL(file);
            }
        });

        // Touch handlers
        mapContainer.addEventListener('touchstart', function (e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                panning = true;
                start = {
                    x: e.touches[0].clientX - pointX,
                    y: e.touches[0].clientY - pointY
                };
            }
        });

        mapContainer.addEventListener('touchmove', function (e) {
            e.preventDefault();
            if (e.touches.length === 1 && panning) {
                pointX = e.touches[0].clientX - start.x;
                pointY = e.touches[0].clientY - start.y;
                setTransform();
            } else if (e.touches.length === 2) {
                panning = false;
                // Handle pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                // Calcular el punto medio entre los dos dedos
                const midX = (touch1.clientX + touch2.clientX) / 2;
                const midY = (touch1.clientY + touch2.clientY) / 2;

                const dist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                if (this.lastDist) {
                    // const delta = dist - this.lastDist;
                    // scale += delta * 0.01;
                    // scale = Math.min(Math.max(0.1, scale), 100); // Permitir hasta 100x zoom
                    // setTransform();
                    // Obtener el punto en coordenadas SVG antes del zoom

                    const svgPointBefore = getPointInSVG(midX, midY);
                    if (!svgPointBefore) return;

                    // // Calcular el factor de zoom basado en la diferencia de distancia
                    const delta = dist - this.lastDist;
                    // const oldScale = scale;
                    scale += delta * 0.01;
                    // let zoomFactor = delta < 0 ? 1.2 : 0.8;
                    // zoomPunto({ x: midX, y: midY },delta);

                    scale = Math.min(Math.max(0.1, scale), 100); // Limitar zoom entre 0.1x y 100x

                    // Aplicar la transformación inicial
                    setTransform();

                    // Obtener el punto en coordenadas SVG después del zoom
                    const svgPointAfter = getPointInSVG(midX, midY);
                    if (!svgPointAfter) return;

                    // Ajustar la posición para mantener el punto bajo los dedos
                    pointX += (svgPointAfter.x - svgPointBefore.x) * scale;
                    pointY += (svgPointAfter.y - svgPointBefore.y) * scale;
                    setTransform();
                }
                this.lastDist = dist;
            }
        });

        mapContainer.addEventListener('touchend', function (e) {
            panning = false;
            this.lastDist = null;
        });

        // Mouse handlers
        mapContainer.addEventListener('mousedown', function (e) {
            if (e.button === 2) {
                panning = false;
                return;
            }
            panning = true;
            start = {
                x: e.clientX - pointX,
                y: e.clientY - pointY
            };

            // Obtener el punto en coordenadas SVG
            const svgPoint = getPointInSVG(e.clientX, e.clientY);
            if (svgPoint) {
                console.log('Coordenadas SVG:', svgPoint.x, svgPoint.y);
            }
        });

        mapContainer.addEventListener('mousemove', function (e) {
            if (panning) {
                pointX = e.clientX - start.x;
                pointY = e.clientY - start.y;
                setTransform();
            }
        });

        mapContainer.addEventListener('mouseup', function () {
            panning = false;
        });

        mapContainer.addEventListener('mouseleave', function () {
            panning = false;
        });

        //#region zoom
        function handleWheelZoom(e) {
            e.preventDefault();
            // console.log(e);
            // const svgPointBefore = getPointInSVG(e.clientX, e.clientY);
            // if (!svgPointBefore) return;
            // Zoom con rueda del raton
            let zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;

            zoomPunto({ x: e.clientX, y: e.clientY }, zoomFactor);

            // const newScale = Math.min(Math.max(0.1, scale * zoomFactor), 100);
            // scale = newScale;
            // setTransform();

            // const svgPointAfter = getPointInSVG(e.clientX, e.clientY);
            // if (!svgPointAfter) return;

            // pointX += (svgPointAfter.x - svgPointBefore.x) * scale;
            // pointY += (svgPointAfter.y - svgPointBefore.y) * scale;
            // setTransform();

        }

        function zoomPunto(p, zoomFactor) {
            const svgPointBefore = getPointInSVG(p.x, p.y);
            if (!svgPointBefore) return;

            const newScale = Math.min(Math.max(0.1, scale * zoomFactor), 100);
            scale = newScale;
            setTransform();

            const svgPointAfter = getPointInSVG(p.x, p.y);
            if (!svgPointAfter) return;

            pointX += (svgPointAfter.x - svgPointBefore.x) * scale;
            pointY += (svgPointAfter.y - svgPointBefore.y) * scale;
            setTransform();
        }

        mapContainer.addEventListener('wheel', handleWheelZoom);

        // Button handlers
        document.getElementById('zoomIn').addEventListener('click', function () {
            zoomPunto({ x: window.innerWidth / 2, y: window.innerHeight / 2 }, 1.2);
        });

        document.getElementById('zoomOut').addEventListener('click', function () {
            zoomPunto({ x: window.innerWidth / 2, y: window.innerHeight / 2 }, 0.8);
        });

        document.getElementById('resetView').addEventListener('click', function () {
            scale = 1;
            pointX = 0;
            pointY = 0;
            setTransform();
        });

        document.getElementById('searchButton').addEventListener('click', function () {
            const searchText = document.getElementById('searchInput').value;
            zoomToText(searchText);
        });

        //#endregion

        function updateTransformCharacters() {
            if (!svgElement) return;
            const characterEls = svgElement.querySelectorAll('.character image');
            characterEls.forEach(char => {
                const size = iconSize / scale;
                char.setAttribute('width', size);
                char.setAttribute('height', size);
                const x = parseFloat(char.getAttribute('data-x') || char.getAttribute('x'));
                const y = parseFloat(char.getAttribute('data-y') || char.getAttribute('y'));
                char.setAttribute('x', x - size / 2);
                char.setAttribute('y', y - size / 2);
            });
        }

        const setTransform = () => {
            if (svgElement) {
                svgElement.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
                updateTransformCharacters();
            }
        };

        function move(image, newX, newY) {
            let x, y;
            //si hay coordenadas como segundo parámetro se asignan a x e y
            ({ x, y } = newX.x && newX.y ? newX : { x: newX, y: newY });
            // Guardar y actualizar posiciones
            image.setAttribute('data-x', x);
            image.setAttribute('data-y', y);

            const size = parseFloat(image.getAttribute('width'));
            image.setAttribute('x', x - size / 2);
            image.setAttribute('y', y - size / 2);
        }

        /**
         * @function rotate
         * @description Rota una imagen alrededor de su centro.
         * @param {SVGImageElement} image - El elemento imagen a rotar.
         * @param {number} angle - El ángulo en grados para rotar la imagen.
         */
        function move2(personaje, lugar) {
            let cs = coordenadas(lugar);
            let img = characters.get(personaje).querySelector('image');
            // if cs or img is not available, do not move
            if (!cs || !img) return;
            move(img, cs);
            if (isOnline) {
                saveMapState(characters.get(personaje));
            }
        }

        function localizacion(personaje) {
            let x = daImagen(personaje).getAttribute('data-x');
            let y = daImagen(personaje).getAttribute('data-y');
            return { x: x, y: y };
        }
        function screenLocation(personaje) {
            let x = daImagen(personaje).getAttribute('x');
            let y = daImagen(personaje).getAttribute('y');
            return { x: x, y: y };
        }

        function near(personaje) {
            const texts = svgElement.querySelectorAll('text');
            let loc = localizacion(personaje);
            let cercano = null;
            let minDistancia = 1000000;
            let dist = 0;

            for (const textEl of texts) {
                locEl = c(textEl);
                dis = Math.sqrt((locEl.x - loc.x) ** 2 + (locEl.y - loc.y) ** 2);
                console.log(dis);
                if (dis < minDistancia) {
                    minDistancia = dis;
                    cercano = textEl.textContent;
                }
            }
            console.log(cercano, minDistancia);
            return cercano;
        }


        function c(el) {
            const bbox = el.getBBox();
            const matrix = el.getCTM();
            const transformedPoint = svgElement.createSVGPoint();
            transformedPoint.x = bbox.x + bbox.width / 2;
            transformedPoint.y = bbox.y + bbox.height / 2;
            const transformedCenter = transformedPoint.matrixTransform(matrix);
            return { x: transformedCenter.x, y: transformedCenter.y };
        }

        function coordenadas(searchText) {
            if (!svgElement) return null;
            if (svgElement.getElementById(searchText)) {
                const el = svgElement.getElementById(searchText);
                return c(el);
            }
            const texts = svgElement.querySelectorAll('text');
            for (const textEl of texts) {
                if (textEl.textContent.includes(searchText)) {
                    return c(textEl);
                }
            }
            return null;
        }


        function zoomToText(text) {
            if (!svgElement) return;
            scale = 1;
            setTransform();
            const transformedCenter = coordenadas(text);
            console.log(transformedCenter.x, transformedCenter.y);

            pointX = -transformedCenter.x * scale + mapContainer.clientWidth / 2;
            pointY = -transformedCenter.y * scale + mapContainer.clientHeight / 2;
            setTransform();
        }

        function adjustContainerToSVG() {
            if (svgElement) {
                // Guardar personajes existentes
                const existingCharacters = svgElement.querySelectorAll('.character');
                existingCharacters.forEach(char => {
                    const image = char.querySelector('image');
                    if (image) {
                        const x = image.getAttribute('x');
                        const y = image.getAttribute('y');
                        const href = image.getAttribute('href');
                        characters.set(char.id, { x, y, href });
                    }
                });

                const bbox = svgElement.getBBox();
                svgContainer.style.width = `${bbox.width}px`;
                svgContainer.style.height = `${bbox.height}px`;
                svgContainer.style.overflow = 'visible';
                pointX = 0;
                pointY = 0;
                scale = 1;
                setTransform();
                setupLayers();
                // Restaurar personajes
                characters.forEach((data, id) => {
                    if (typeof data === 'object' && data.href) {
                        addCharacterToMap(data.href, { x: data.x, y: data.y });
                    }
                });
            }
        }

        function setupLayers() {
            if (!svgElement) return;

            const layersList = document.getElementById('layersList');
            const searchInput = document.getElementById('layerSearch');
            layersList.innerHTML = '';

            // Obtener todos los grupos del SVG
            const groups = svgElement.querySelectorAll('g');
            const processedIds = new Set();
            const layerItems = []; // Array para almacenar las referencias a los items

            groups.forEach(group => {
                let id = group.getAttribute('id');
                if (!id || processedIds.has(id)) return;

                processedIds.add(id);

                const div = document.createElement('div');
                div.className = 'layer-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `layer-${id}`;
                checkbox.checked = true;

                const label = document.createElement('label');
                label.htmlFor = `layer-${id}`;
                label.textContent = id;

                div.appendChild(checkbox);
                div.appendChild(label);

                checkbox.addEventListener('change', () => {
                    group.style.display = checkbox.checked ? 'inline' : 'none';
                });

                layersList.appendChild(div);
                layerItems.push({ element: div, id: id.toLowerCase() }); // Guardar referencia
            });

            // Añadir funcionalidad de búsqueda
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                layerItems.forEach(item => {
                    if (item.id.includes(searchTerm)) {
                        item.element.classList.remove('hidden');
                    } else {
                        item.element.classList.add('hidden');
                    }
                });
            });
        }

        /**
         * Obtiene el punto en el SVG correspondiente a las coordenadas de la pantalla
         * @param {number} screenX - Coordenada X de la pantalla
         * @param {number} screenY - Coordenada Y de la pantalla
         * @returns {object} - Objeto con las coordenadas del punto en el SVG {x,y}
         */
        function getPointInSVG(screenX, screenY) {
            if (!svgElement) return null;

            // Crear un punto SVG
            const svgPoint = svgElement.createSVGPoint();

            // Ajustar las coordenadas al punto de la pantalla
            svgPoint.x = screenX;
            svgPoint.y = screenY;

            // Obtener la matriz de transformación actual del SVG
            const CTM = svgElement.getScreenCTM();
            if (!CTM) return null;

            // Invertir la matriz y transformar el punto
            try {
                const invertedCTM = CTM.inverse();
                const transformedPoint = svgPoint.matrixTransform(invertedCTM);

                return {
                    x: transformedPoint.x,
                    y: transformedPoint.y
                };
            } catch (e) {
                console.error('Error transforming point:', e);
                return null;
            }
        }

        function addCharacterToMap(imageUrl, url) {
            if (!svgElement) return;

            const charGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            charGroup.setAttribute('class', 'character');

            // Extraer el nombre del archivo de la URL
            const fileName = url.split('/').pop(); // Obtiene el último segmento de la URL
            const baseName = fileName.substring(0, fileName.lastIndexOf('.')) // Elimina la extensión
                .replace(/[^a-zA-Z0-9]/g, '_'); // Sanitiza el nombre

            charGroup.id = baseName;
            // Crear imagen
            const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
            image.setAttribute('href', imageUrl);
            console.log(fileName);

            image.setAttribute('data-name', baseName);
            console.log(baseName);

            const size = iconSize / scale; // Tamaño inicial ajustado al zoom actual
            image.setAttribute('width', size);
            image.setAttribute('height', size);
            image.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Posicionar en el centro del viewport actual
            const point = getPointInSVG(window.innerWidth / 2, window.innerHeight / 2);
            const x = point.x;
            const y = point.y;
            // Guardar las coordenadas centrales como datos
            image.setAttribute('data-x', x);
            image.setAttribute('data-y', y);

            const titleElement = document.createElementNS("http://www.w3.org/2000/svg", "title");
            titleElement.textContent = baseName;
            charGroup.insertBefore(titleElement, charGroup.firstChild);
            // Posicionar teniendo en cuenta el tamaño
            image.setAttribute('x', x - size / 2);
            image.setAttribute('y', y - size / 2);

            // Añadir cruz de referencia (inicialmente oculta)
            const crossGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            crossGroup.setAttribute('class', 'position-cross');
            crossGroup.style.display = 'none';

            // Línea horizontal
            const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            hLine.setAttribute('stroke', 'white');
            hLine.setAttribute('stroke-width', '1');

            // Línea vertical
            const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vLine.setAttribute('stroke', 'white');
            vLine.setAttribute('stroke-width', '1');

            crossGroup.appendChild(hLine);
            crossGroup.appendChild(vLine);
            charGroup.appendChild(image);
            charGroup.appendChild(crossGroup);

            svgElement.appendChild(charGroup);

            setupCharacterDrag(charGroup);

            // Nuevo listener para shift+wheel: rota el personaje y guarda la rotación en modo online
            charGroup.addEventListener('wheel', (e) => {
                if (e.shiftKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    let img = charGroup.querySelector('image');
                    console.log('Rotating character...', charGroup.id);
                    let currentRotation = parseFloat(img.getAttribute('data-rotation')) || 0;
                    // let currentRotation = parseFloat(charGroup.getAttribute('data-rotation')) || 0;
                    let delta = e.deltaY > 0 ? 15 : -15;
                    let newRotation = (currentRotation + delta) % 360;
                    // img.setAttribute('data-rotation', newRotation);
                    rotate(img, newRotation);
                    if (isOnline) {
                        saveMapState(charGroup);
                    }
                }
            });

            //#region Rotación con dos dedos

            // Ángulo inicial y rotación de inicio
            let startAngle = null;
            let startRotation = 0;

            // Función para calcular el ángulo entre dos toques
            function getAngle(touch1, touch2) {
                return Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
            }

            // Evento de inicio de toque
            charGroup.addEventListener('touchstart', (e) => {
                // Activar rotación solo si hay dos dedos en la pantalla
                if (e.touches.length === 2) {
                    panning = false;
                    e.preventDefault();

                    let img = charGroup.querySelector('image');
                    startRotation = parseFloat(img.getAttribute('data-rotation')) || 0;
                    startAngle = getAngle(e.touches[0], e.touches[1]);

                    console.log('Iniciando rotación del personaje...', charGroup.id);
                }
            });

            // Evento de movimiento de toque
            charGroup.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && startAngle !== null) {
                    panning = false;
                    e.preventDefault();
                    e.stopPropagation();

                    let img = charGroup.querySelector('image');
                    let currentAngle = getAngle(e.touches[0], e.touches[1]);
                    let angleDelta = currentAngle - startAngle;

                    // Calcular nueva rotación
                    let newRotation = (startRotation + angleDelta) % 360;
                    if (newRotation < 0) newRotation += 360;

                    // img.setAttribute('data-rotation', newRotation);
                    rotate(img, newRotation);
                    console.log('Rotando personaje...', charGroup.id, 'Nuevo ángulo:', newRotation);
                }
            });

            // Evento de fin de toque
            charGroup.addEventListener('touchend', (e) => {
                if (startAngle !== null) {
                    // Si quedan menos de 2 toques, terminar la rotación
                    if (e.touches.length < 2) {
                        startAngle = null;

                        if (isOnline) {
                            saveMapState(charGroup);
                        }
                        console.log('Rotación finalizada');
                    }
                }
            });

            //#endregion
            // Evento de cancelación de toque
            charGroup.addEventListener('touchcancel', (e) => {
                startAngle = null;
            });

            const id = baseName;
            charGroup.setAttribute('id', id);
            characters.set(id, charGroup);

            charGroup.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();

                activeCharacter = charGroup;
                const contextMenu = document.getElementById('characterContextMenu');
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${e.pageX}px`;
                contextMenu.style.top = `${e.pageY}px`;

                // Actualizar texto del toggle path
                const togglePathItem = document.getElementById('togglePath');
                togglePathItem.textContent = rastro ? 'Ocultar camino' : 'Mostrar camino';

            });
        }

        const setupCharacterDrag = charElement => {
            let startX, startY, originalPos;
            let isDragging = false;
            let hasStartedDrag = false;
            const image = () => charElement.querySelector('image');
            const cross = () => charElement.querySelector('.position-cross');

            const updateCross = (x, y) => {
                const crossEl = cross();
                const [hLine, vLine] = crossEl.children;
                const halfCross = (iconSize / 2) / scale; // Mantener 50px en pantalla dividido entre 2
                hLine.setAttribute('x1', x - halfCross);
                hLine.setAttribute('x2', x + halfCross);
                hLine.setAttribute('y1', y);
                hLine.setAttribute('y2', y);
                vLine.setAttribute('x1', x);
                vLine.setAttribute('x2', x);
                vLine.setAttribute('y1', y - halfCross);
                vLine.setAttribute('y2', y + halfCross);
                const strokeWidth = 2 / scale;
                hLine.setAttribute('stroke-width', strokeWidth);
                vLine.setAttribute('stroke-width', strokeWidth);
            };

            const startDragging = e => {
                if (e.button === 2) return;
                e.stopPropagation();
                
                const evt = e.touches ? e.touches[0] : e;
                const point = getPointInSVG(evt.clientX, evt.clientY);
                startX = point.x;
                startY = point.y;
                isDragging = true;
                hasStartedDrag = false;
                
                originalPos = {
                    x: parseFloat(image().getAttribute('data-x')) || (parseFloat(image().getAttribute('x')) + parseFloat(image().getAttribute('width')) / 2),
                    y: parseFloat(image().getAttribute('data-y')) || (parseFloat(image().getAttribute('y')) + parseFloat(image().getAttribute('height')) / 2)
                };
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchend', stopDragging);
            };

            const drag = e => {
                if (!isDragging) return;
                e.preventDefault();
                
                const evt = e.touches ? e.touches[0] : e;
                const point = getPointInSVG(evt.clientX, evt.clientY);
                const dx = point.x - startX;
                const dy = point.y - startY;
                
                // Solo iniciar el arrastre real si el movimiento es suficiente
                if (!hasStartedDrag) {
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 2) return; // Umbral de movimiento mínimo
                    
                    hasStartedDrag = true;
                    draggedCharacter = charElement;
                    cross().style.display = 'block';
                    image().style.opacity = '0.5';
                    characterRoutes.set(charElement, [{ x: originalPos.x, y: originalPos.y }]);
                }
                
                if (hasStartedDrag) {
                    const newX = originalPos.x + dx;
                    const newY = originalPos.y + dy;
                    move(image(), newX, newY);
                    updateCross(newX, newY);
                    updateCharacterRoute(charElement, newX, newY);
                    if (isOnline) saveMapState(draggedCharacter);
                }
            };

            const stopDragging = e => {
                if (!isDragging) return;
                isDragging = false;

                if (hasStartedDrag) {
                    image().style.opacity = '1';
                    cross().style.display = 'none';

                    if (rastro) {
                        const ruta = characterRoutes.get(charElement);
                        if (ruta && ruta.length >= 2) {
                            try {
                                const path = simplifySvgPath(ruta);
                                let pathElem = charElement.querySelector('.character-route');
                                if (!pathElem) {
                                    pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
                                    pathElem.classList.add('character-route');
                                    pathElem.classList.add(`${draggedCharacter.id}-route`);
                                    pathElem.setAttribute('fill', 'none');
                                    pathElem.setAttribute('stroke', 'red');
                                    pathElem.setAttribute('stroke-width', 0.5);
                                    pathElem.setAttribute('stroke-dasharray', '1 1');
                                    svgElement.appendChild(pathElem);
                                }
                                pathElem.setAttribute('d', path);
                            } catch (error) {
                                console.error('Error al crear el path:', error);
                            }
                        }
                    }
                } else {
                    // Si no hubo arrastre, considerar como click
                    activeCharacter = charElement;
                }

                draggedCharacter = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', stopDragging);
                document.removeEventListener('touchend', stopDragging);
            };

            charElement.addEventListener('mousedown', startDragging);
            charElement.addEventListener('touchstart', startDragging);
        };

        // Añadir control del panel lateral
        document.getElementById('togglePanel').addEventListener('click', () => {
            document.getElementById('sidePanel').classList.toggle('open');
        });

        // Cerrar panel al hacer clic en el mapa
        mapContainer.addEventListener('click', (e) => {
            if (!e.target.closest('#sidePanel') && !e.target.closest('#togglePanel')) {
                document.getElementById('sidePanel').classList.remove('open');
            }
        });

        /**
         * @function daImagen
         * @description Retrieves the image element associated with a given character.
         * @param {string} personaje - The name of the character.
         * @returns {HTMLImageElement | null | undefined} The image element if found, otherwise null or undefined.
         */
        function daImagen(personaje) {
            return characters.get(personaje)?.querySelector('image');
        }

        async function initializeMap() {
            try {
                // Cargar el mapa por defecto
                await loadMapFromURL('mapas/Elahiun.svg');
                // Cargar el personaje por defecto
                await loadCharacterFromURL('img/tokens/Rosssel.png');
            } catch (error) {
                console.error('Error en la inicialización:', error);
            }
        }

        // Modificar el listener de DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM cargado, iniciando mapa...');
            initializeMap();
        });

        // Función para cargar el mapa desde URL
        async function loadMapFromURL(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const reader = new FileReader();

                return new Promise((resolve, reject) => {
                    reader.onload = function (event) {
                        svgContainer.innerHTML = event.target.result;
                        svgElement = svgContainer.querySelector('svg');
                        adjustContainerToSVG();
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(blob);
                });
            } catch (error) {
                console.error('Error cargando el mapa:', error);
                throw error;
            }
        }

        // Función para cargar personaje desde URL
        async function loadCharacterFromURL(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const reader = new FileReader();

                return new Promise((resolve, reject) => {
                    reader.onload = function (event) {
                        const fileName = url.split('/').pop();
                        const char = addCharacterToMap(event.target.result, url);
                        resolve(char);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error cargando el personaje:', error);
                throw error;
            }
        }

        // Añadir variables para sincronización
        let isOnline = false;
        const syncButton = document.getElementById('syncButton');

        const toggleOnlineMode = () => {
            isOnline = !isOnline;
            syncButton.classList.toggle('online');
            syncButton.title = isOnline ? 'Modo online' : 'Modo offline';
            isOnline ? startSync() : stopSync();
        };

        const startSync = () => {
            console.log('Iniciando sincronización...');
            database.ref('mapState/characters/').on('value', snapshot => {
                const data = snapshot.val();
                if (!data) return;
                characters.forEach((charEl, name) => {
                    if (draggedCharacter && draggedCharacter.querySelector('image').getAttribute('data-name') === name) {
                        console.log('Skipping dragged character:', name);
                        return;
                    }
                    if (data[name]) {
                        const charImage = daImagen(name);
                        if (charImage) {
                            move(charImage, parseFloat(data[name].x), parseFloat(data[name].y));
                            if (data[name].rotation) {
                                rotate(charImage, parseFloat(data[name].rotation));
                            }
                        }
                    }
                });
            });
        };

        const stopSync = () => {
            console.log('Deteniendo sincronización...');
            database.ref('mapState/characters/').off();
        };

        function rotate(img, angle) {
            img.style.transformBox = 'fill-box';
            img.style.transformOrigin = 'center';
            img.setAttribute('data-rotation', angle);
            img.style.transform = `rotate(${angle}deg)`;

        }
        const saveMapState = character => {
            if (!isOnline) return;
            const img = character ? character.querySelector('image') : draggedCharacter.querySelector('image');
            const name = img.getAttribute('data-name');
            const x = img.getAttribute('data-x');
            const y = img.getAttribute('data-y');
            const rotation = img.getAttribute('data-rotation') || 0;
            database.ref(`mapState/characters/${name}`).set({ x, y, rotation })
                .then(() => { /* guardado exitoso */ })
                .catch(error => console.error('Error al guardar:', error));
        };

        // Añadir listener para el botón de sincronización
        syncButton.addEventListener('click', toggleOnlineMode);

        document.getElementById('togglePath').addEventListener('click', () => {
            console.log('Toggling path...');
            rastro = !rastro;
            svgElement.querySelectorAll('.character-route').forEach(el => el.style.display = rastro ? 'block' : 'none');
            // Actualizar texto del toggle path
            const togglePathItem = document.getElementById('togglePath');
            togglePathItem.textContent = rastro ? 'Ocultar camino' : 'Mostrar camino';

        });


        document.getElementById('deleteRoute').addEventListener('click', () => {
            if (!activeCharacter) return;
            console.log('Deleting routes...');
            svgElement.querySelectorAll(`.${activeCharacter.id}-route`).forEach(el => el.remove());
        });


        document.getElementById('deleteCharacter').addEventListener('click', () => {
            if (!activeCharacter) return;
            console.log('Deleting character...');

            const id = activeCharacter.getAttribute('id');
            characterRoutes.delete(activeCharacter); // Eliminar la ruta
            svgElement.querySelectorAll(`.${activeCharacter.id}-route`).forEach(el => el.remove());

            activeCharacter.remove();
            characters.delete(id);
            activeCharacter = null;
        });

        // Cerrar el menú al hacer click fuera
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#characterContextMenu')) {
                document.getElementById('characterContextMenu').style.display = 'none';
            }
        });
    </script>
</body>

</html>