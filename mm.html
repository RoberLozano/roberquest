<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Map</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        #map-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: #333;
        }

        .controls {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 20px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
        }

        #fileInput {
            display: none;
        }

        .map-button {
            background: #333;
            color: #fff;
            border: 1px solid #444;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }

        .map-button:hover {
            background: #444;
        }

        #searchBox {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 20px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
        }

        #svg-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        #layersPanel {
            position: relative;
            top: 0;
            right: 0;
            margin-bottom: 20px;
            background: #2a2a2a;
            color: #fff;
            width: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        #layersHeader {
            padding: 10px;
            border-bottom: 1px solid #444;
            position: sticky;
            top: 0;
            background: #2a2a2a;
            z-index: 2;
        }

        #layerSearch {
            width: calc(100% - 16px);
            padding: 5px 8px;
            margin: 10px 0;
            border: 1px solid #444;
            border-radius: 3px;
            font-size: 14px;
            background: #333;
            color: #fff;
        }

        #layersList {
            max-height: 40vh;
            overflow-y: auto;
            padding: 10px;
        }

        .layer-item.hidden {
            display: none;
        }

        .layer-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .layer-item input {
            margin-right: 8px;
        }

        .layer-item label {
            cursor: pointer;
            user-select: none;
            color: #fff;
        }

        /* Estilos para el panel lateral */
        #sidePanel {
            position: fixed;
            top: 0;
            right: -320px;
            /* Cambiar left por right */
            width: 300px;
            height: 100%;
            background: #1a1a1a;
            color: #fff;
            transition: right 0.3s ease;
            /* Cambiar left por right en transition */
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            /* Invertir sombra */
        }

        #sidePanel.open {
            right: 0;
            /* Cambiar left por right */
        }

        #togglePanel {
            position: fixed;
            top: 10px;
            right: 10px;
            /* Cambiar left por right */
            z-index: 1001;
            background: rgba(26, 26, 26, 0.8);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
        }

        /* Añadir estilos para el botón de wifi */
        .wifi-button {
            position: fixed;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .wifi-button svg {
            width: 24px;
            height: 24px;
            fill: #666;
        }

        .wifi-button.online svg {
            fill: #4CAF50;
        }

        .wifi-button:hover {
            background: rgba(0, 0, 0, 0.9);
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/4.7.0/firebase.js"></script>
    <script src='js/coor.js'></script>
    <script src='js/utils.js'></script>
    <script src='js/D.js'></script>
    <script src='js/habilidades.js'></script>
    <script src='js/inventario.js'></script>
    <script src='js/localizaciones.js'></script>
    <script src='js/armaduras.js'></script>
    <script src='js/rol.js'></script>
</head>

<body>
    <div id="map-container">
        <div id="svg-container"></div>
    </div>

    <button id="togglePanel">☰</button>

    <div id="sidePanel">
        <div class="controls">
            <label for="fileInput" class="map-button">
                Load Map
            </label>
            <input type="file" id="fileInput" accept="image/svg+xml">
            <label for="characterInput" class="map-button">
                Add Character
            </label>
            <input type="file" id="characterInput" accept="image/*" style="display: none;">
            <button class="map-button" id="zoomIn">+</button>
            <button class="map-button" id="zoomOut">-</button>
            <button class="map-button" id="resetView">Reset</button>
        </div>
        <div id="searchBox">
            <input type="text" id="searchInput" placeholder="Enter name to zoom">
            <button class="map-button" id="searchButton">Zoom</button>
        </div>
        <div id="layersPanel">
            <div id="layersHeader">
                <h3>Capas</h3>
                <input type="text" id="layerSearch" placeholder="Buscar capas...">
            </div>
            <div id="layersList"></div>
        </div>
    </div>

    <!-- Añadir botón de sincronización después del sidePanel -->
    <button class="wifi-button" id="syncButton" title="Modo offline">
        <svg viewBox="0 0 24 24">
            <path
                d="M12,21L15.6,16.2C14.6,15.45 13.35,15 12,15C10.65,15 9.4,15.45 8.4,16.2L12,21M12,3C7.95,3 4.21,4.34 1.2,6.6L3,9C5.5,7.12 8.62,6 12,6C15.38,6 18.5,7.12 21,9L22.8,6.6C19.79,4.34 16.05,3 12,3M12,9C9.3,9 6.81,9.89 4.8,11.4L6.6,13.8C8.1,12.67 9.97,12 12,12C14.03,12 15.9,12.67 17.4,13.8L19.2,11.4C17.19,9.89 14.7,9 12,9Z" />
        </svg>
    </button>

    <script>
        let scale = 1;
        let panning = false;
        let pointX = 0;
        let pointY = 0;
        let start = { x: 0, y: 0 };
        let svgElement = null;
        let draggedCharacter = null;
        let characters = new Map(); // Para mantener registro de personajes

        const mapContainer = document.getElementById("map-container");
        const svgContainer = document.getElementById("svg-container");


        // File input handler
        document.getElementById('fileInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file && file.type === "image/svg+xml") {
                const reader = new FileReader();
                reader.onload = function (event) {
                    svgContainer.innerHTML = event.target.result;
                    svgElement = svgContainer.querySelector('svg');
                    adjustContainerToSVG();
                }
                reader.readAsText(file);
            } else {
                alert("Please upload a valid SVG file.");
            }
        });

        // Character input handler
        document.getElementById('characterInput').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    addCharacterToMap(event.target.result, e.target.files[0].name);
                }
                reader.readAsDataURL(file);
            }
        });

        // Touch handlers
        mapContainer.addEventListener('touchstart', function (e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                panning = true;
                start = {
                    x: e.touches[0].clientX - pointX,
                    y: e.touches[0].clientY - pointY
                };
            }
        });

        mapContainer.addEventListener('touchmove', function (e) {
            e.preventDefault();
            if (e.touches.length === 1 && panning) {
                pointX = e.touches[0].clientX - start.x;
                pointY = e.touches[0].clientY - start.y;
                setTransform();
            } else if (e.touches.length === 2) {
                // Handle pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const dist = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                if (this.lastDist) {
                    const delta = dist - this.lastDist;
                    scale += delta * 0.01;
                    scale = Math.min(Math.max(0.1, scale), 100); // Permitir hasta 100x zoom
                    setTransform();
                }
                this.lastDist = dist;
            }
        });

        mapContainer.addEventListener('touchend', function (e) {
            panning = false;
            this.lastDist = null;
        });

        // Mouse handlers
        mapContainer.addEventListener('mousedown', function (e) {
            panning = true;
            start = {
                x: e.clientX - pointX,
                y: e.clientY - pointY
            };

            // Obtener el punto en coordenadas SVG
            const svgPoint = getPointInSVG(e.clientX, e.clientY);
            if (svgPoint) {
                console.log('Coordenadas SVG:', svgPoint.x, svgPoint.y);
            }
        });

        mapContainer.addEventListener('mousemove', function (e) {
            if (panning) {
                pointX = e.clientX - start.x;
                pointY = e.clientY - start.y;
                setTransform();
            }
        });

        mapContainer.addEventListener('mouseup', function () {
            panning = false;
        });

        mapContainer.addEventListener('mouseleave', function () {
            panning = false;
        });

        //#region zoom
        function handleWheelZoom(e) {
            e.preventDefault();
            // console.log(e);

            const svgPointBefore = getPointInSVG(e.clientX, e.clientY);

            if (!svgPointBefore) {
                return;
            }

            // console.log(svgPointBefore);

            // Zoom con rueda del raton
            let zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;

            const newScale = Math.min(Math.max(0.1, scale * zoomFactor), 100);
            scale = newScale;

            setTransform();

            const svgPointAfter = getPointInSVG(e.clientX, e.clientY);
            if (!svgPointAfter) return;

            pointX += (svgPointAfter.x - svgPointBefore.x) * scale;
            pointY += (svgPointAfter.y - svgPointBefore.y) * scale;

            setTransform();

        }

        mapContainer.addEventListener('wheel', handleWheelZoom);

        // Button handlers
        document.getElementById('zoomIn').addEventListener('click', function () {
            scale *= 1.2;
            scale = Math.min(100, scale); // Permitir hasta 100x zoom
            setTransform();
        });

        document.getElementById('zoomOut').addEventListener('click', function () {
            scale *= 0.8;
            scale = Math.max(0.1, scale);
            setTransform();
        });

        document.getElementById('resetView').addEventListener('click', function () {
            scale = 1;
            pointX = 0;
            pointY = 0;
            setTransform();
        });

        document.getElementById('searchButton').addEventListener('click', function () {
            const searchText = document.getElementById('searchInput').value;
            zoomToText(searchText);
        });

        //#endregion

        function updateTransformCharacters() {
            if (!svgElement) return;
            const characterEls = svgElement.querySelectorAll('.character image');
            characterEls.forEach(char => {
                const size = 50 / scale;
                char.setAttribute('width', size);
                char.setAttribute('height', size);
                const x = parseFloat(char.getAttribute('data-x') || char.getAttribute('x'));
                const y = parseFloat(char.getAttribute('data-y') || char.getAttribute('y'));
                char.setAttribute('x', x - size / 2);
                char.setAttribute('y', y - size / 2);
            });
        }

        const setTransform = () => {
            if (svgElement) {
                svgElement.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
                updateTransformCharacters();
            }
        };

        function move(image, newX, newY) {
            // Guardar y actualizar posiciones
            image.setAttribute('data-x', newX);
            image.setAttribute('data-y', newY);

            const size = parseFloat(image.getAttribute('width'));
            image.setAttribute('x', newX - size / 2);
            image.setAttribute('y', newY - size / 2);
        }


        function c(el) {
            const bbox = el.getBBox();
            const matrix = el.getCTM();
            const transformedPoint = svgElement.createSVGPoint();
            transformedPoint.x = bbox.x + bbox.width / 2;
            transformedPoint.y = bbox.y + bbox.height / 2;
            const transformedCenter = transformedPoint.matrixTransform(matrix);
            return { x: transformedCenter.x, y: transformedCenter.y };
        }

        function coordenadas(searchText) {
            if (!svgElement) return null;
            const texts = svgElement.querySelectorAll('text');
            for (const textEl of texts) {
                if (textEl.textContent.includes(searchText)) {
                    return c(textEl);
                }
            }
            return null;
        }


        function zoomToText(text) {
            if (!svgElement) return;
            scale = 1;
            setTransform();
            const transformedCenter = coordenadas(text);
            console.log(transformedCenter.x, transformedCenter.y);

            pointX = -transformedCenter.x * scale + mapContainer.clientWidth / 2;
            pointY = -transformedCenter.y * scale + mapContainer.clientHeight / 2;

            setTransform();
        }

        function adjustContainerToSVG() {
            if (svgElement) {
                // Guardar personajes existentes
                const existingCharacters = svgElement.querySelectorAll('.character');
                existingCharacters.forEach(char => {
                    const image = char.querySelector('image');
                    if (image) {
                        const x = image.getAttribute('x');
                        const y = image.getAttribute('y');
                        const href = image.getAttribute('href');
                        characters.set(char.id, { x, y, href });
                    }
                });

                const bbox = svgElement.getBBox();
                svgContainer.style.width = `${bbox.width}px`;
                svgContainer.style.height = `${bbox.height}px`;
                svgContainer.style.overflow = 'visible';
                pointX = 0;
                pointY = 0;
                scale = 1;
                setTransform();
                setupLayers();

                // Restaurar personajes
                characters.forEach((data, id) => {
                    if (typeof data === 'object' && data.href) {
                        addCharacterToMap(data.href, { x: data.x, y: data.y });
                    }
                });
            }
        }

        function setupLayers() {
            if (!svgElement) return;

            const layersList = document.getElementById('layersList');
            const searchInput = document.getElementById('layerSearch');
            layersList.innerHTML = '';

            // Obtener todos los grupos del SVG
            const groups = svgElement.querySelectorAll('g');
            const processedIds = new Set();
            const layerItems = []; // Array para almacenar las referencias a los items

            groups.forEach(group => {
                let id = group.getAttribute('id');
                if (!id || processedIds.has(id)) return;

                processedIds.add(id);

                const div = document.createElement('div');
                div.className = 'layer-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `layer-${id}`;
                checkbox.checked = true;

                const label = document.createElement('label');
                label.htmlFor = `layer-${id}`;
                label.textContent = id;

                div.appendChild(checkbox);
                div.appendChild(label);

                checkbox.addEventListener('change', () => {
                    group.style.display = checkbox.checked ? 'inline' : 'none';
                });

                layersList.appendChild(div);
                layerItems.push({ element: div, id: id.toLowerCase() }); // Guardar referencia
            });

            // Añadir funcionalidad de búsqueda
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                layerItems.forEach(item => {
                    if (item.id.includes(searchTerm)) {
                        item.element.classList.remove('hidden');
                    } else {
                        item.element.classList.add('hidden');
                    }
                });
            });
        }

        function getPointInSVG(screenX, screenY) {
            if (!svgElement) return null;

            // Crear un punto SVG
            const svgPoint = svgElement.createSVGPoint();

            // Ajustar las coordenadas al punto de la pantalla
            svgPoint.x = screenX;
            svgPoint.y = screenY;

            // Obtener la matriz de transformación actual del SVG
            const CTM = svgElement.getScreenCTM();
            if (!CTM) return null;

            // Invertir la matriz y transformar el punto
            try {
                const invertedCTM = CTM.inverse();
                const transformedPoint = svgPoint.matrixTransform(invertedCTM);

                return {
                    x: transformedPoint.x,
                    y: transformedPoint.y
                };
            } catch (e) {
                console.error('Error transforming point:', e);
                return null;
            }
        }

        function addCharacterToMap(imageUrl, url) {
            if (!svgElement) return;


            const charGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            charGroup.setAttribute('class', 'character');

            // Extraer el nombre del archivo de la URL
            const fileName = url.split('/').pop(); // Obtiene el último segmento de la URL
            const baseName = fileName.substring(0, fileName.lastIndexOf('.')) // Elimina la extensión
                .replace(/[^a-zA-Z0-9]/g, '_'); // Sanitiza el nombre

            // Crear imagen
            const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
            image.setAttribute('href', imageUrl);
            console.log(fileName);

            image.setAttribute('data-name', baseName);
            console.log(baseName);

            const size = 50 / scale; // Tamaño inicial ajustado al zoom actual
            image.setAttribute('width', size);
            image.setAttribute('height', size);
            image.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            // Posicionar en el centro del viewport actual
            const point = getPointInSVG(window.innerWidth / 2, window.innerHeight / 2);
            const x = point.x;
            const y = point.y;
            // Guardar las coordenadas centrales como datos
            image.setAttribute('data-x', x);
            image.setAttribute('data-y', y);

            const titleElement = document.createElementNS("http://www.w3.org/2000/svg", "title");
            titleElement.textContent = baseName;
            charGroup.insertBefore(titleElement, charGroup.firstChild);
            // Posicionar teniendo en cuenta el tamaño
            image.setAttribute('x', x - size / 2);
            image.setAttribute('y', y - size / 2);

            // Añadir cruz de referencia (inicialmente oculta)
            const crossGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            crossGroup.setAttribute('class', 'position-cross');
            crossGroup.style.display = 'none';

            // Línea horizontal
            const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            hLine.setAttribute('stroke', 'white');
            hLine.setAttribute('stroke-width', '2');

            // Línea vertical
            const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            vLine.setAttribute('stroke', 'white');
            vLine.setAttribute('stroke-width', '2');

            crossGroup.appendChild(hLine);
            crossGroup.appendChild(vLine);
            charGroup.appendChild(image);
            charGroup.appendChild(crossGroup);

            svgElement.appendChild(charGroup);

            setupCharacterDrag(charGroup);

            const id = baseName;
            charGroup.setAttribute('id', id);
            characters.set(id, charGroup);
        }

        const setupCharacterDrag = charElement => {
            let startX, startY, originalPos;
            const image = () => charElement.querySelector('image');
            const cross = () => charElement.querySelector('.position-cross');

            const updateCross = (x, y) => {
                const crossEl = cross();
                const [hLine, vLine] = crossEl.children;
                const halfCross = 25 / scale; // Mantener 50px en pantalla dividido entre 2
                hLine.setAttribute('x1', x - halfCross);
                hLine.setAttribute('x2', x + halfCross);
                hLine.setAttribute('y1', y);
                hLine.setAttribute('y2', y);
                vLine.setAttribute('x1', x);
                vLine.setAttribute('x2', x);
                vLine.setAttribute('y1', y - halfCross);
                vLine.setAttribute('y2', y + halfCross);
                const strokeWidth = 2 / scale;
                hLine.setAttribute('stroke-width', strokeWidth);
                vLine.setAttribute('stroke-width', strokeWidth);
            };

            const startDragging = e => {
                e.stopPropagation();
                draggedCharacter = charElement;
                const evt = e.touches ? e.touches[0] : e;
                const point = getPointInSVG(evt.clientX, evt.clientY);
                startX = point.x; startY = point.y;
                cross().style.display = 'block';
                image().style.opacity = '0.5';
                originalPos = {
                    x: parseFloat(image().getAttribute('data-x')) || (parseFloat(image().getAttribute('x')) + parseFloat(image().getAttribute('width')) / 2),
                    y: parseFloat(image().getAttribute('data-y')) || (parseFloat(image().getAttribute('y')) + parseFloat(image().getAttribute('height')) / 2)
                };
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag);
                document.addEventListener('mouseup', stopDragging);
                document.addEventListener('touchend', stopDragging);
            };

            const drag = e => {
                if (!draggedCharacter) return;
                e.preventDefault();
                const evt = e.touches ? e.touches[0] : e;
                const point = getPointInSVG(evt.clientX, evt.clientY);
                const dx = point.x - startX;
                const dy = point.y - startY;
                const newX = originalPos.x + dx;
                const newY = originalPos.y + dy;
                move(image(), newX, newY);
                updateCross(newX, newY);
                if (isOnline) saveMapState(draggedCharacter);
            };

            const stopDragging = () => {
                if (draggedCharacter) {
                    image().style.opacity = '1';
                    cross().style.display = 'none';
                }
                draggedCharacter = null;
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('touchmove', drag);
                document.removeEventListener('mouseup', stopDragging);
                document.removeEventListener('touchend', stopDragging);
            };

            charElement.addEventListener('mousedown', startDragging);
            charElement.addEventListener('touchstart', startDragging);
        };

        // Añadir control del panel lateral
        document.getElementById('togglePanel').addEventListener('click', () => {
            document.getElementById('sidePanel').classList.toggle('open');
        });

        // Cerrar panel al hacer clic en el mapa
        mapContainer.addEventListener('click', (e) => {
            if (!e.target.closest('#sidePanel') && !e.target.closest('#togglePanel')) {
                document.getElementById('sidePanel').classList.remove('open');
            }
        });



        /**
         * @function daImagen
         * @description Retrieves the image element associated with a given character.
         * @param {string} personaje - The name of the character.
         * @returns {HTMLImageElement | null | undefined} The image element if found, otherwise null or undefined.
         */
        function daImagen(personaje) {
            return characters.get(personaje)?.querySelector('image');
        }


        async function initializeMap() {
            try {
                // Cargar el mapa por defecto
                await loadMapFromURL('mapas/Elahiun.svg');
                // Cargar el personaje por defecto
                await loadCharacterFromURL('img/tokens/Rosssel.png');
            } catch (error) {
                console.error('Error en la inicialización:', error);
            }
        }

        // Modificar el listener de DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM cargado, iniciando mapa...');
            initializeMap();
        });

        // Función para cargar el mapa desde URL
        async function loadMapFromURL(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const reader = new FileReader();

                return new Promise((resolve, reject) => {
                    reader.onload = function (event) {
                        svgContainer.innerHTML = event.target.result;
                        svgElement = svgContainer.querySelector('svg');
                        adjustContainerToSVG();
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsText(blob);
                });
            } catch (error) {
                console.error('Error cargando el mapa:', error);
                throw error;
            }
        }

        // Función para cargar personaje desde URL
        async function loadCharacterFromURL(url) {
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                const reader = new FileReader();

                return new Promise((resolve, reject) => {
                    reader.onload = function (event) {
                        const fileName = url.split('/').pop();
                        const char = addCharacterToMap(event.target.result, url);
                        resolve(char);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error cargando el personaje:', error);
                throw error;
            }
        }

        // Añadir variables para sincronización
        let isOnline = false;
        const syncButton = document.getElementById('syncButton');

        const toggleOnlineMode = () => {
            isOnline = !isOnline;
            syncButton.classList.toggle('online');
            syncButton.title = isOnline ? 'Modo online' : 'Modo offline';
            isOnline ? startSync() : stopSync();
        };

        const startSync = () => {
            console.log('Iniciando sincronización...');
            database.ref('mapState/characters/').on('value', snapshot => {
                const data = snapshot.val();
                if (!data) return;
                characters.forEach((charEl, name) => {
                    if (draggedCharacter && draggedCharacter.querySelector('image').getAttribute('data-name') === name) {
                        console.log('Skipping dragged character:', name);
                        return;
                    }
                    if (data[name]) {
                        const charImage = daImagen(name);
                        if (charImage) {
                            move(charImage, parseFloat(data[name].x), parseFloat(data[name].y));
                        }
                    }
                });
            });
        };

        const saveMapState = character => {
            if (!isOnline) return;
            const img = character ? character.querySelector('image') : draggedCharacter.querySelector('image');
            const name = img.getAttribute('data-name');
            const x = img.getAttribute('data-x');
            const y = img.getAttribute('data-y');
            database.ref(`mapState/characters/${name}`).set({ x, y })
                .then(() => { /* guardado exitoso */ })
                .catch(error => console.error('Error al guardar:', error));
        };

        // Añadir listener para el botón de sincronización
        syncButton.addEventListener('click', toggleOnlineMode);
    </script>
</body>

</html>